<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>Rust Hacking - Scalar Type (Part 1)</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><style>@font-face {font-display:swap;font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url("/fonts/jetbrains-mono-v20-latin-regular.woff2") format("woff2")}</style><style>body{--primary-color:#5871a2;--primary-pale-color:#5871a210;--text-color:#3c4043;--text-pale-color:#94969f;--bg-color:#fff;--highlight-mark-color:#5f75b035;--callout-note-color:#5871a2;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460;--main-font:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,
      "Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,
      "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol",
      "Noto Color Emoji";--code-font:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,
      "Liberation Mono","Courier New",monospace;--homepage-max-width:768px;--main-max-width:768px;--avatar-size:125px;--icon-size:20px;--homepage-font-size:16px;--homepage-line-height:1.75;--paragraph-font-size:16px;--paragraph-line-height:1.75;--aside-font-size:15px;--img-border-radius:4px;--callout-border-radius:0;--detail-border-radius:0;--dark-mode-img-brightness:.75;--dark-mode-chart-brightness:.75;--inline-code-border-radius:2px;--inline-code-bg-color:var(--primary-pale-color);--block-code-border-radius:0;--block-code-border-color:var(--primary-color);--detail-border-color:var(--primary-color)}body.dark{--primary-color:#5d77ac;--primary-pale-color:#5d77ac20;--text-color:#9197a5;--text-pale-color:#747983;--bg-color:#202124;--highlight-mark-color:#5f75b035;--callout-note-color:#5d77ac;--callout-important-color:#8062b0;--callout-warning-color:#936e51;--callout-alert-color:#bc5252;--callout-question-color:#477389;--callout-tip-color:#3c8460}</style><link href=/main.css rel=stylesheet><script data-website-id=ade60e13-6907-4f1c-8a75-7c45b57b43d3 defer src=https://umami-phi-eight.vercel.app/script.js></script><body class=post><script>const theme=sessionStorage.getItem('theme');const match=window.matchMedia("(prefers-color-scheme: dark)").matches;if(theme&&theme=='dark'||!theme&&match){document.body.classList.add('dark');const a=document.querySelector('link#hl');if(a)a.href='/hl-dark.css'}</script><header class=blur><div id=header-wrapper><nav><a class=instant href=/>curtain</a><span class=separator>::</span><a class=instant href=/posts>blog</a></nav><div id=btns><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><div id=blank></div><aside><nav><ul><li><a class=h2 href=#scalar-type>Scalar Type</a><li><a class=h2 href=#analysis-scalar-type-ida>Analysis Scalar Type （IDA)</a><li><a class=h2 href=#debugging-and-hacking-gdb>Debugging And Hacking （GDB）</a> <ul><li><a class=h3 href=#hacking-string-slice>Hacking String Slice</a></ul><li><a class=h2 href=#总结>总结</a></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>Rust Hacking - Scalar Type (Part 1)</h1><div id=post-info><div id=date><span id=publish>2024-05-16</span></div><div id=tags><a class=instant href=https://curtainp.github.io/tags/rust><span>#</span>Rust</a><a class=instant href=https://curtainp.github.io/tags/hacking><span>#</span>Hacking</a></div></div><p>最近遇到很多<a rel="nofollow noreferrer" href=https://www.rust-lang.org/> Rust</a> 的二进制程序，在分析中遇到了比较多的问题，所以本系列打算从基础开始，总结一些分析 Rust 二进制的基本步骤以及相关的技巧。<h2 id=scalar-type>Scalar Type<a aria-label="Anchor link for: scalar-type" class=zola-anchor href=#scalar-type style=visibility:hidden></a></h2><p>首先我们看看在 Rust 中 Scalar Type 在编译之后会如何在内存中表示。我们新建一个示例项目：<pre class=language-sh data-lang=sh style=background:#2e3440;color:#d8dee9><code class=language-sh data-lang=sh><span style=color:#88c0d0>cargo</span><span> new --bin hello_scalar_data_type
</span></code></pre><p>打开 <strong>main.rs</strong> 写入如下代码：<pre class=language-rust data-lang=rust style=background:#2e3440;color:#d8dee9><code class=language-rust data-lang=rust><span style=color:#81a1c1>fn </span><span style=color:#88c0d0>main</span><span>() {
</span><span>    </span><span style=color:#81a1c1>let</span><span> my_hel </span><span style=color:#81a1c1>= </span><span style=color:#a3be8c>"hello"</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> my_wor </span><span style=color:#81a1c1>= </span><span style=color:#8fbcbb>String</span><span style=color:#81a1c1>::</span><span>from(</span><span style=color:#a3be8c>"world"</span><span>)</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> my_num </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>41</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> my_float </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>3.14</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> my_char </span><span style=color:#81a1c1>= </span><span style=color:#a3be8c>'A'</span><span style=color:#eceff4>;
</span><span>    println!(</span><span style=color:#a3be8c>"with str: </span><span style=color:#ebcb8b>{my_hel} {my_wor}</span><span style=color:#a3be8c>, num: </span><span style=color:#ebcb8b>{my_num}</span><span style=color:#a3be8c>, float: </span><span style=color:#ebcb8b>{my_float}</span><span style=color:#a3be8c>, char: </span><span style=color:#ebcb8b>{my_char} </span><span style=color:#a3be8c>"</span><span>)</span><span style=color:#eceff4>;
</span><span>}
</span></code></pre><p>在这个例子中，我们测试了 Rust 中的基本 Scalar Type, 编译执行，可以得到预期结果：<pre class=language-sh data-lang=sh style=background:#2e3440;color:#d8dee9><code class=language-sh data-lang=sh><span style=color:#88c0d0>with</span><span> str: hello world, num: 41, float: 3.14, char: A
</span></code></pre><h2 id=analysis-scalar-type-ida>Analysis Scalar Type （IDA)<a aria-label="Anchor link for: analysis-scalar-type-ida" class=zola-anchor href=#analysis-scalar-type-ida style=visibility:hidden></a></h2><p>在 IDA Free 中加载编译后的二进制，待分析完成后，我们可以看到停在如下图所示位置：<figure><img loading=lazy src=./ida.png></figure><p>与 C-like 语言不同，项目（hello_scalar_data_type) 的 main 函数地址作为参数传递给 Rust 的 <a rel="nofollow noreferrer" href=https://github.com/rust-lang/rust/blob/master/library/std/src/rt.rs>Runtime</a> 入口点 <code>lang_start</code>. 并且，查看 IDA 左侧的符号列表 可看到几乎所有符号（除了引用的外部库函数符号）都经过 mangling 处理。双击 hello_scalar_data_type 进入 user-main.<figure><img loading=lazy src=./ida1.png></figure><p>查看 <strong>aHellowithStrNu</strong> 处字符串字面量：<figure><img loading=lazy src=./ida2.png></figure><p>可以看到与 C-like 的字符串不同，Rust 中所有字符串字面量统一保存在 <strong>rodata</strong> 节中，字符串无 ‘\0’ 结尾。 整个字符串池会以 ’\0’ 结尾。 而字符串 “world“ 则是动态分配到内存中：<figure><img loading=lazy src=./ida3.png></figure><p>接下来的逻辑初始化相关变量，最后调用 <code>print</code> 输出到 <strong>stdout</strong>.<p><figure><img loading=lazy src=./ida4.png></figure> 最后将字符串 ”world“ 的内存释放，然后进程结束。 <h2 id=debugging-and-hacking-gdb>Debugging And Hacking （GDB）<a aria-label="Anchor link for: debugging-and-hacking-gdb" class=zola-anchor href=#debugging-and-hacking-gdb style=visibility:hidden></a></h2><p>接下来在 <strong>GDB</strong> 中验证上述分析过程，并尝试 hacking 相关内存。<p><figure><img loading=lazy src=./ida5.png></figure> GDB 下断到 <code>scalar_type::main</code> 上， <code>start</code> 断下来后看到堆栈确实是由 Runtime 中的 <code>lang_start</code> 走过来的。 <p>接下来看看字符串池：<p><figure><img loading=lazy src=./ida6.png></figure> 同样，与静态分析的结果一致。 <h3 id=hacking-string-slice>Hacking String Slice<a aria-label="Anchor link for: hacking-string-slice" class=zola-anchor href=#hacking-string-slice style=visibility:hidden></a></h3><p>尝试在此字符串字面量后接上 “Hacked“<figure><img loading=lazy src=./ida7.png></figure><p>成功写入了内存，但之后字符 ’H’ 输出了。首先，只有字符 ’H’ 输出是因为替换的原本字符是换行符。后续的字符串未输出是因为 Rust 中字符串字面量是通过 <strong>&str</strong> 类型使用的（胖指针）：<pre class=language-c data-lang=c style=background:#2e3440;color:#d8dee9><code class=language-c data-lang=c><span style=color:#81a1c1>struct</span><span> &</span><span style=color:#8fbcbb>str </span><span>{
</span><span>  </span><span style=color:#81a1c1>char *</span><span>ptr</span><span style=color:#eceff4>;
</span><span>  </span><span style=color:#8fbcbb>size_t</span><span> len</span><span style=color:#eceff4>;
</span><span>}
</span></code></pre><p>在二进制文件中也可以验证这一点：<figure><img loading=lazy src=./ida8.png></figure><p>另外，从此处也可以得出， <code>println!</code> 中引用的字符串会由于 <strong>format specification</strong> 而分割成不同的部分：<figure><img loading=lazy src=./ida9.png></figure><p>看看这些不同的部分在何时进行处理的，在 <strong>len</strong> 地址处下内存访问断点， <code>continue</code> 程序，会断在如下逻辑处：<p><figure><img loading=lazy src=./ida10.png></figure> 在判断 <strong>len</strong> 是否为 0，此处跳转不会发生，继续单步到 <code>call</code> 处： <figure><img loading=lazy src=./ida11.png></figure><p>根据 <strong>rax</strong> 处指令看起来像是内存分配，首先搜索一下内存当前访问的字符串，仅有一处命中（二进制文件自身内存）：<figure><img loading=lazy src=./ida12.png></figure><p>单步步过此 <code>call</code> 之后，再次搜索，发现在 <strong>heap</strong> 上多了一处命中，即验证猜测，此处为字符串在 <strong>heap</strong> 上分配空间，待 <strong>format specification</strong> 被替换。<figure><img loading=lazy src=./ida13.png></figure><p>后续其他字符串部分也会同样在 <strong>heap</strong> 上分配，并填入相应的变量。所以，此处 Hacking 还需要更改 str slice 的 len 字段:<p><figure><img loading=lazy src=./ida14.png></figure> 更新之后即可看到 Hacked 成功： <figure><img loading=lazy src=./ida15.png></figure><h2 id=总结>总结<a aria-label="Anchor link for: 总结" class=zola-anchor href=#总结 style=visibility:hidden></a></h2><ul><li>Rust 二进制程序编译后由于自带一个小的 Runtime, 编译后的二进制大小一般较大。<li>符号名经过 <strong>mangling</strong> 处理，增加了静态分析的难度。<li>Scalar Type 的内存布局符合预期，值得注意的是，所有字符串字面量统一存储在 <strong>rodata</strong> 节中，只有整个字面量以 ’\0’ 结尾， 由于通过切片引用，所以各个字符串之间没有额外的分隔符。</ul></article><div class=giscus></div><script async crossorigin data-category=Announcements data-category-id=DIC_kwDOKyFr1M4Cjcdy data-emit-metadata=0 data-input-position=bottom data-lang=en data-loading=lazy data-mapping=pathname data-reactions-enabled=1 data-repo=curtainp/curtainp.github.io data-repo-id=R_kgDOKyFr1A data-strict=0 data-theme=preferred_color_scheme src=https://giscus.app/client.js></script></div><footer><div class=copyright><p>© 2024 curtain</div></footer></main></div><script src=/js/lightense.min.js></script><script src=/js/main.js></script>